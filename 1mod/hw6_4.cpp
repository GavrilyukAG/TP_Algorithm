/*
Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n. Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве. Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении. Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
6_4. Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.
*/
#include <iostream>
#include <cassert>
#include <ctime>

bool IsGreater(const int& first, const int& second) {
    return (first > second);
}

template<class P, class T>
int Partition(P* arr, int n, int k, const T& cmp) {
    while(n > 0) {
        if(n == 1) {
            return arr[0];
        }

        // srand(time(0));
        int pivot = rand() % n;
        if(pivot != 0) {
            std::swap(arr[pivot], arr[0]);
        }

        int  j = n - 1;
        for(int i = n - 1; i > 0;) {
            if(cmp(arr[i], arr[0])) {
                std::swap(arr[i--], arr[j--]);
            } else {
                --i;
            }
        }
        std::swap(arr[j], arr[0]);
        pivot = j;

        if(pivot > k) {
            n = pivot;
        } else if(pivot < k) {
            arr += pivot + 1;
            n -= pivot + 1;
            k -= pivot + 1;
        } else {
            return arr[pivot];
        }
    }
    return -1;
}

int main() {
    srand(time(0));

    int n = 0;
    int k = 0;
    std::cin >> n >> k;
    assert(n > 0 && k < n);

    int* arr = new int[n];
    for(int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    std::cout << Partition(arr, n, k, IsGreater);

    delete[] arr;
    return 0;
}
